/*
 * Copyright (C) 2021 Muntashir Al-Islam
 *
 * Licensed according to the LICENSE file in this repository.
 */

package io.github.muntashirakon.crypto.spake2;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;

import javax.security.auth.Destroyable;

import io.github.muntashirakon.crypto.ed25519.Curve;
import io.github.muntashirakon.crypto.ed25519.Ed25519;
import io.github.muntashirakon.crypto.ed25519.Ed25519CurveParameterSpec;
import io.github.muntashirakon.crypto.ed25519.Ed25519Field;
import io.github.muntashirakon.crypto.ed25519.Ed25519ScalarOps;
import io.github.muntashirakon.crypto.ed25519.FieldElement;
import io.github.muntashirakon.crypto.ed25519.GroupElement;
import io.github.muntashirakon.crypto.ed25519.Utils;

@SuppressWarnings("unused")
public class Spake2Context implements Destroyable {
    /**
     * Maximum message size in bytes
     */
    public static final int MAX_MSG_SIZE = 32;
    /**
     * Maximum key size in bytes
     */
    public static final int MAX_KEY_SIZE = 64;

    private static byte[] intToByteArray(int[] ints) {
        byte[] bytes = new byte[ints.length];
        for (int i = 0; i < bytes.length; ++i) {
            bytes[i] = (byte) ints[i];
        }
        return bytes;
    }

    // Package private for testing purposes
    static GroupElement[] getGEFromTable(Curve curve, int[] intTable) {
        byte[] table = intToByteArray(intTable);
        Ed25519Field f = curve.getField();
        GroupElement[] ge = new GroupElement[table.length / (3 * 32)];
        byte[] bytes = new byte[32];
        for (int i = 0; i < ge.length; ++i) {
            System.arraycopy(table, i * 96, bytes, 0, 32);
            FieldElement ypx = f.fromByteArray(bytes);
            System.arraycopy(table, i * 96 + 32, bytes, 0, 32);
            FieldElement ymx = f.fromByteArray(bytes);
            System.arraycopy(table, i * 96 + 64, bytes, 0, 32);
            FieldElement xy2d = f.fromByteArray(bytes);
            ge[i] = GroupElement.precomp(curve, ypx, ymx, xy2d);
        }
        return ge;
    }

    // https://datatracker.ietf.org/doc/html/draft-ietf-kitten-krb-spake-preauth-01#appendix-B
    private static final String SEED_N = "edwards25519 point generation seed (N)";
    private static final String SEED_M = "edwards25519 point generation seed (M)";

    private static final int[] PRECOMP_TABLE_N = new int[]{
            0x43, 0xFE, 0xA4, 0xBE, 0x26, 0x95, 0xFF, 0x8A, 0xDD, 0xD3, 0x71, 0x28, 0x63, 0x86, 0x31,
            0xB0, 0x32, 0x02, 0xA5, 0xD1, 0x95, 0x80, 0x6A, 0xCF, 0xFB, 0x4C, 0x07, 0xFC, 0xB6, 0x3B,
            0x24, 0x67, 0xF0, 0xC7, 0x1A, 0x57, 0x9F, 0x66, 0x1D, 0x6A, 0x55, 0x97, 0x8B, 0xC1, 0x05,
            0x07, 0xB3, 0x70, 0x47, 0x78, 0x14, 0xAA, 0x77, 0xDD, 0x66, 0x4B, 0xE6, 0x17, 0x2D, 0x27,
            0x1B, 0x3B, 0x6A, 0x0A, 0x81, 0x39, 0x04, 0x13, 0x80, 0x6B, 0x54, 0x7E, 0x26, 0xF3, 0xB0,
            0xA2, 0xCA, 0x96, 0x32, 0x8E, 0x98, 0x44, 0x30, 0xFF, 0x8C, 0x2D, 0x67, 0x77, 0x16, 0xF1,
            0xE9, 0x96, 0x8B, 0x33, 0x06, 0x61, 0xFB, 0x78, 0x6B, 0xFB, 0xD8, 0x00, 0x66, 0x8B, 0x17,
            0x5A, 0x26, 0x2D, 0x71, 0xCD, 0x03, 0xA0, 0x14, 0x93, 0xB3, 0xFF, 0xED, 0x68, 0x29, 0xE4,
            0x84, 0x37, 0x81, 0xBB, 0xCD, 0x06, 0x30, 0x40, 0xC2, 0x95, 0xBB, 0xCC, 0xFB, 0x1F, 0x88,
            0x00, 0xA9, 0xC5, 0x3D, 0x15, 0x41, 0x2B, 0x19, 0x00, 0x46, 0x1A, 0xFB, 0x25, 0xE4, 0x8D,
            0x87, 0x0C, 0xEF, 0x3F, 0xC9, 0xBB, 0xCD, 0x2F, 0xDE, 0x78, 0x7F, 0xA8, 0x5C, 0xA8, 0xF3,
            0x4D, 0x18, 0xE9, 0xF4, 0x80, 0x8C, 0x6C, 0x1F, 0x5B, 0xFF, 0xFD, 0x33, 0xDF, 0x6E, 0xFC,
            0xE1, 0xA2, 0x1E, 0xF2, 0xC1, 0xA8, 0x2E, 0x60, 0x50, 0x2B, 0x1C, 0x7B, 0x5C, 0x00, 0xCC,
            0x18, 0x35, 0x4C, 0x36, 0xF8, 0x19, 0xC9, 0x07, 0xF4, 0x99, 0xB9, 0x88, 0xEF, 0x58, 0x71,
            0x33, 0xCB, 0x98, 0x9C, 0xC6, 0xF3, 0x5E, 0x21, 0x68, 0xAC, 0x8C, 0xA0, 0x2A, 0x0A, 0xAA,
            0xB1, 0x9C, 0xDE, 0x59, 0x43, 0xAB, 0x7B, 0x1A, 0x9E, 0x62, 0x8A, 0xFF, 0xA5, 0x5D, 0x6E,
            0x77, 0xC9, 0x73, 0xED, 0x77, 0x08, 0x00, 0xFC, 0xC1, 0x21, 0xE7, 0x5D, 0xFE, 0x48, 0xD4,
            0x3C, 0x8D, 0x18, 0x5C, 0xE6, 0xCB, 0x41, 0xC7, 0x61, 0x03, 0x23, 0x53, 0x96, 0x08, 0x26,
            0xC3, 0x7C, 0x0B, 0x8E, 0x55, 0xC4, 0xF9, 0x21, 0x44, 0x72, 0x56, 0xBE, 0xA3, 0xF0, 0x37,
            0xF1, 0x25, 0x54, 0xA6, 0x3B, 0xB1, 0x4D, 0xF9, 0x8B, 0xE4, 0x1F, 0x77, 0x28, 0x39, 0x9C,
            0x83, 0x9B, 0xC3, 0xE4, 0xAA, 0x46, 0x8F, 0x14, 0x14, 0x6B, 0x9E, 0x8C, 0x9C, 0xF6, 0x3D,
            0x9D, 0xDC, 0x5C, 0xC3, 0x61, 0x64, 0x15, 0xAE, 0xD1, 0x2A, 0x2E, 0x88, 0xF5, 0x8F, 0x0C,
            0xB5, 0x50, 0x39, 0x29, 0x51, 0x6A, 0xCE, 0x29, 0x7C, 0x99, 0x42, 0xF3, 0xCE, 0xCF, 0x83,
            0x29, 0x27, 0xD6, 0x8B, 0x20, 0x27, 0x79, 0x62, 0xF4, 0x71, 0xD1, 0xBA, 0x68, 0x8C, 0x31,
            0x32, 0xAC, 0xE6, 0x16, 0xF7, 0x8F, 0x18, 0x70, 0x75, 0x11, 0x81, 0xDA, 0x82, 0xD1, 0x69,
            0xC8, 0x2E, 0xB2, 0xBE, 0x0E, 0x5B, 0x73, 0xAB, 0x2A, 0x37, 0x6E, 0x2C, 0x1D, 0x69, 0xEA,
            0x9D, 0x0D, 0x92, 0x96, 0xC9, 0xDD, 0x14, 0xEF, 0x0D, 0x2B, 0x96, 0xD0, 0xCF, 0x43, 0xC8,
            0x48, 0xDD, 0x69, 0x78, 0x2F, 0x6B, 0xAD, 0x5C, 0xEB, 0x38, 0x6E, 0xC3, 0x1D, 0xC9, 0xB2,
            0xE4, 0xAC, 0x7F, 0x88, 0x9E, 0x83, 0x5E, 0xB1, 0xC8, 0x4C, 0x7E, 0x13, 0x8E, 0x92, 0x95,
            0x51, 0x8E, 0x3D, 0x91, 0x92, 0x0D, 0xFC, 0xB6, 0x64, 0x82, 0xC8, 0xAD, 0x0A, 0xE5, 0x52,
            0xB5, 0x33, 0x3F, 0x52, 0x77, 0x9E, 0x1F, 0xEA, 0x93, 0x83, 0xBD, 0x38, 0xB5, 0x4F, 0xD1,
            0x9E, 0x56, 0xDA, 0x9E, 0x6B, 0x6A, 0xDA, 0x00, 0xC5, 0x1B, 0xEC, 0x7B, 0xE2, 0x8B, 0x78,
            0x86, 0x61, 0x66, 0x29, 0xDE, 0x54, 0xA9, 0xCF, 0xC8, 0x59, 0x66, 0xCF, 0xB5, 0xA2, 0x61,
            0x99, 0x81, 0x6D, 0xD1, 0xAE, 0xAD, 0xE3, 0xC6, 0x09, 0x84, 0x5D, 0xF0, 0x82, 0xB7, 0x05,
            0x34, 0x39, 0x67, 0x75, 0x75, 0x92, 0x90, 0x39, 0xB7, 0x10, 0x78, 0x43, 0xB0, 0xB6, 0x78,
            0xD9, 0x0B, 0xF6, 0x4C, 0xE8, 0xF2, 0x8B, 0x0D, 0x69, 0xC4, 0x5D, 0x40, 0xDD, 0xBC, 0xC5,
            0x82, 0x35, 0x30, 0x6E, 0xA9, 0x4F, 0x2E, 0x5F, 0x7A, 0x08, 0x9E, 0xFE, 0x44, 0xAE, 0xB9,
            0x81, 0x13, 0x0C, 0x75, 0x77, 0xE5, 0x48, 0x54, 0x38, 0x8F, 0x8F, 0x87, 0x9B, 0xA8, 0xEF,
            0x62, 0x60, 0x56, 0x90, 0x9F, 0x08, 0x6A, 0x5D, 0xF5, 0xF5, 0xE3, 0x6E, 0xAA, 0xC8, 0x34,
            0x1B, 0xBF, 0xFD, 0x65, 0xCD, 0x61, 0x93, 0xCF, 0x6E, 0x2C, 0x97, 0x22, 0x7A, 0x23, 0x91,
            0x02, 0xF6, 0x1E, 0x3E, 0x21, 0xC6, 0xEB, 0x66, 0xCC, 0x2D, 0x29, 0x6F, 0x41, 0x9D, 0xFF,
            0x50, 0x06, 0x49, 0x90, 0xB1, 0x58, 0x91, 0x3C, 0x23, 0xD6, 0xC3, 0xCC, 0x19, 0xE0, 0x43,
            0xC1, 0xBA, 0xEA, 0xAD, 0xED, 0x04, 0x3D, 0xF0, 0x2E, 0x6E, 0xEF, 0xF2, 0xD2, 0x28, 0xA5,
            0xE3, 0x13, 0xCB, 0xBE, 0xEE, 0xE6, 0xC4, 0x23, 0xE0, 0xEA, 0xAF, 0xB3, 0xEF, 0x87, 0x83,
            0x51, 0xC2, 0x5A, 0xCC, 0xC5, 0x38, 0xA5, 0xA1, 0xE5, 0xF5, 0x0A, 0x77, 0x46, 0xF1, 0xA0,
            0x6A, 0x27, 0xFC, 0xB8, 0xA1, 0x37, 0x62, 0x21, 0x47, 0xD1, 0xCE, 0x24, 0xB6, 0x84, 0x3E,
            0x73, 0xFA, 0x11, 0x10, 0x43, 0xB7, 0x1E, 0x4E, 0x4E, 0xB3, 0xF7, 0xE7, 0x15, 0x1F, 0xD7,
            0xE9, 0x37, 0x90, 0x76, 0x65, 0xDA, 0xA3, 0xB7, 0x7A, 0x66, 0x90, 0x47, 0x9F, 0xCF, 0xAB,
            0x9D, 0x64, 0xE6, 0x75, 0xAB, 0xEE, 0xBF, 0x07, 0xF0, 0xAC, 0xE3, 0x50, 0xBC, 0x78, 0x86,
            0x25, 0x41, 0x26, 0x27, 0x53, 0xE4, 0xF8, 0x12, 0xE6, 0x89, 0x7B, 0x19, 0x7E, 0xC3, 0x1C,
            0x39, 0x91, 0x04, 0xF6, 0xC3, 0x70, 0x28, 0xE3, 0xA6, 0x18, 0xC8, 0xB9, 0xB4, 0xF0, 0x6A,
            0x88, 0xD6, 0x6A, 0xA8, 0xFE, 0x56, 0x63, 0xF4, 0x23, 0xEB, 0x2E, 0x62, 0x21, 0x54, 0x16,
            0xD4, 0xFC, 0x72, 0xB7, 0xBF, 0x10, 0x13, 0xE3, 0x04, 0x81, 0x1B, 0x4B, 0xF6, 0x2A, 0x1A,
            0x02, 0xE2, 0xD6, 0x59, 0x3F, 0x1D, 0x33, 0xCA, 0xC5, 0xBE, 0x85, 0x93, 0xDA, 0xB4, 0xA4,
            0xB9, 0x77, 0x5E, 0x37, 0xB4, 0x82, 0x1E, 0x2B, 0x14, 0x03, 0xB3, 0x06, 0x9E, 0x99, 0x46,
            0xB0, 0x2F, 0x52, 0xE7, 0x03, 0x76, 0x5C, 0x19, 0xC0, 0xF7, 0x94, 0xC5, 0x97, 0x1B, 0xE3,
            0xF4, 0xA0, 0x2D, 0xE5, 0x11, 0xA2, 0x9A, 0x5C, 0xFA, 0x2A, 0x55, 0x00, 0x9F, 0xC6, 0xAA,
            0x69, 0xDD, 0x38, 0xBB, 0x28, 0x78, 0x24, 0xB0, 0x18, 0x16, 0xD6, 0x38, 0x65, 0x2F, 0xEE,
            0x6A, 0xC2, 0x7A, 0x56, 0xA7, 0x7B, 0xE7, 0xEE, 0xC0, 0xC7, 0x5D, 0x0A, 0x43, 0x42, 0x03,
            0x59, 0x54, 0x4B, 0x1B, 0x2C, 0xDD, 0xCA, 0x2C, 0x4B, 0x9C, 0x45, 0xD6, 0xDC, 0x51, 0xF0,
            0xF7, 0xE0, 0x1B, 0x4B, 0xD0, 0xFF, 0xF5, 0x1A, 0x05, 0xC3, 0xBE, 0xC0, 0xFE, 0x17, 0x7D,
            0x39, 0xD2, 0x8B, 0x67, 0x9F, 0xD8, 0x7B, 0xF7, 0x7E, 0x64, 0x68, 0x05, 0x21, 0xF4, 0x22,
            0x72, 0x9D, 0xE5, 0xE0, 0x15, 0xB9, 0xA7, 0x80, 0xD9, 0x39, 0x7A, 0xAD, 0xCA, 0x6C, 0x07,
            0x9A, 0x8F, 0xFD, 0x97, 0xB7, 0x50, 0x04, 0x69, 0xD8, 0x01, 0xDD, 0x77, 0x18, 0xA6, 0x60,
            0x1E, 0x86, 0x88, 0x2D, 0x2D, 0xCA, 0xA9, 0xC6, 0xB6, 0x49, 0xAD, 0x15, 0x84, 0xEA, 0xAD,
            0x3F, 0x0A, 0xF8, 0xCD, 0xD1, 0x4B, 0xFD, 0xA8, 0x71, 0xCB, 0xA7, 0xB5, 0xD1, 0xBC, 0x51,
            0x4B, 0x01, 0x09, 0xD3, 0x36, 0xD2, 0x0A, 0xCF, 0x82, 0x72, 0x94, 0xAB, 0xEF, 0x95, 0x6F,
            0x46, 0x34, 0xD8, 0xA5, 0x32, 0x27, 0xFD, 0x5B, 0xEC, 0x21, 0xA5, 0x7C, 0x21, 0xAB, 0xFE,
            0xFC, 0xA6, 0x60, 0x2B, 0x05, 0x17, 0x84, 0xFE, 0xFA, 0x65, 0x21, 0x87, 0x5D, 0xC0, 0x8E,
            0xC2, 0x01, 0xE5, 0x9E, 0xE5, 0x1D, 0x6D, 0x4A, 0xF0, 0x09, 0x4B, 0x0D, 0xE9, 0x9D, 0xA6,
            0xA4, 0xCB, 0x56, 0xFB, 0xCC, 0x55, 0x84, 0x0E, 0x20, 0x6E, 0x2F, 0x5F, 0x7C, 0x49, 0xCA,
            0x46, 0xF6, 0x16, 0x15, 0x7D, 0xE7, 0xF9, 0x73, 0xDD, 0x86, 0xFD, 0xA5, 0x01, 0xE5, 0x68,
            0x5F, 0x0B, 0xA0, 0xBE, 0x38, 0xBF, 0xF5, 0x00, 0x95, 0xE4, 0xF7, 0xC7, 0xA3, 0xE8, 0x8B,
            0x8B, 0xBE, 0xCA, 0x83, 0x9D, 0x66, 0xA7, 0x42, 0x15, 0xBD, 0x6A, 0x74, 0x81, 0xA0, 0xBA,
            0xC4, 0xD4, 0xF0, 0x83, 0xE6, 0x24, 0x7E, 0x2C, 0x12, 0x57, 0x2E, 0x2E, 0x9B, 0xDB, 0xCA,
            0x04, 0x38, 0x9A, 0x49, 0xAB, 0x82, 0x7D, 0x23, 0xB4, 0xC1, 0x1E, 0xCC, 0xC6, 0x55, 0x37,
            0x41, 0x4B, 0x0C, 0xE5, 0xB5, 0x7D, 0xDE, 0xAB, 0xF5, 0xA9, 0xDF, 0x16, 0x0D, 0xE4, 0x9A,
            0x0B, 0xA4, 0x6D, 0x14, 0x3E, 0x55, 0xB3, 0xE7, 0x67, 0x25, 0x8E, 0x31, 0xAF, 0x35, 0x81,
            0x50, 0x3E, 0x5F, 0xAD, 0xAC, 0x76, 0x12, 0x01, 0x3B, 0xBC, 0x94, 0x21, 0xE4, 0x46, 0x5F,
            0x15, 0x51, 0x84, 0x9F, 0x06, 0x1E, 0x79, 0xC8, 0xB8, 0xF8, 0x45, 0x53, 0x5D, 0xC1, 0x60,
            0x01, 0xA2, 0xDF, 0xE5, 0x69, 0x87, 0x21, 0x19, 0x45, 0xB4, 0x53, 0x91, 0x69, 0x05, 0x4C,
            0x3E, 0x45, 0x93, 0x97, 0x2F, 0xE1, 0x24, 0xD0, 0xD6, 0xB3, 0x12, 0xBE, 0x5B, 0xC6, 0x63,
            0x11, 0xD0, 0x23, 0xF9, 0x51, 0x9B, 0xD2, 0xFA, 0xF1, 0x7B, 0x02, 0x71, 0x5E, 0xA3, 0x3C,
            0xF7, 0x71, 0x41, 0xD6, 0x72, 0x90, 0x25, 0x85, 0x82, 0x75, 0x17, 0xF5, 0x31, 0x9B, 0xC8,
            0x60, 0xEE, 0xAD, 0xB4, 0xF6, 0x81, 0x75, 0x95, 0xDE, 0x7D, 0xB3, 0x14, 0x82, 0x9A, 0x69,
            0x21, 0x42, 0x11, 0x01, 0x13, 0x1F, 0xEC, 0xD9, 0x93, 0xA9, 0x6B, 0x07, 0xB4, 0xCE, 0xE8,
            0xEE, 0xF6, 0x16, 0xB0, 0xCF, 0x71, 0xA8, 0x68, 0x9E, 0xDD, 0xD6, 0x0C, 0xA0, 0x4D, 0xFE,
            0xEA, 0x95, 0xAA, 0x3D, 0x3B, 0x58, 0x74, 0xAC, 0x76, 0xA7, 0x2E, 0x66, 0x42, 0x94, 0xB0,
            0xAD, 0x45, 0x12, 0xFD, 0x26, 0x6C, 0x2A, 0xFE, 0xC1, 0x98, 0x5B, 0xFB, 0x31, 0x88, 0xE1,
            0xD2, 0xF1, 0x3B, 0x56, 0xB3, 0x49, 0x97, 0x34, 0x61, 0xD3, 0xE9, 0x52, 0x06, 0x10, 0xAB,
            0x40, 0xC0, 0xC7, 0x72, 0x4D, 0xB8, 0xFF, 0x68, 0x3B, 0x54, 0x72, 0x4C, 0xFE, 0xBA, 0x01,
            0x0C, 0x77, 0xBF, 0x94, 0x5D, 0xC8, 0x70, 0x82, 0x79, 0x70, 0x01, 0x2C, 0xFE, 0x52, 0x44,
            0xA2, 0x0E, 0x59, 0xFA, 0x57, 0x39, 0x48, 0xE6, 0xC1, 0xC3, 0xC1, 0x44, 0x13, 0xD2, 0xC9,
            0x7F, 0xE3, 0x80, 0x91, 0x4E, 0x4F, 0x5A, 0x20, 0x9F, 0x1F, 0x70, 0x43, 0x61, 0x6B, 0x0B,
            0x08, 0x7B, 0xB0, 0x83, 0x18, 0xA7, 0x61, 0x46, 0x21, 0x78, 0xD1, 0x9A, 0xC6, 0xC3, 0xE6,
            0x59, 0xDF, 0x0A, 0x4D, 0xE2, 0x35, 0x31, 0x9F, 0x3A, 0x08, 0x86, 0xE8, 0x08, 0xC4, 0x60,
    };

    private static final int[] PRECOMP_TABLE_M = new int[]{
            0x22, 0x81, 0xE2, 0x10, 0x8E, 0xCF, 0xC8, 0xEE, 0x61, 0xC5, 0xAF, 0x20, 0x39, 0x8B, 0x9D,
            0xC8, 0xC6, 0xCD, 0x8A, 0x1B, 0x61, 0x7A, 0xCA, 0x71, 0xE0, 0x6B, 0x02, 0x20, 0x31, 0x67,
            0x41, 0x74, 0x7F, 0x33, 0x1B, 0x86, 0x5E, 0xEC, 0xEA, 0x6C, 0x0B, 0x00, 0x2B, 0x44, 0xED,
            0xAC, 0x38, 0xF0, 0xDB, 0x74, 0x3C, 0x74, 0xE5, 0x14, 0x54, 0x35, 0xBE, 0x33, 0x87, 0x16,
            0xDF, 0x75, 0x62, 0x69, 0x9F, 0x80, 0x69, 0x41, 0x2F, 0x5B, 0xF3, 0x5A, 0xD8, 0x22, 0x94,
            0x18, 0x7B, 0x00, 0xDF, 0x75, 0x27, 0x4C, 0x8F, 0x7D, 0x9F, 0x7B, 0x66, 0x37, 0xC2, 0x5D,
            0x3E, 0xA8, 0xE0, 0x53, 0x1E, 0x09, 0x61, 0x35, 0x5B, 0xA6, 0x9C, 0x02, 0x4F, 0x6B, 0x8A,
            0x7C, 0x82, 0x9A, 0x78, 0x81, 0xB4, 0xB0, 0xB5, 0xFD, 0x1F, 0x19, 0x57, 0x5F, 0xF0, 0x47,
            0x0D, 0x8A, 0x50, 0x3C, 0xCF, 0xDF, 0x86, 0x62, 0x48, 0x23, 0xFC, 0x24, 0xD9, 0xA7, 0x12,
            0x00, 0xB4, 0x5E, 0x7C, 0xDA, 0x08, 0x8A, 0x68, 0x37, 0x2C, 0x81, 0x06, 0x07, 0x42, 0x41,
            0x44, 0x94, 0x7E, 0x4D, 0x83, 0xC0, 0x62, 0xA5, 0x87, 0x58, 0x9E, 0xD3, 0x1F, 0x9E, 0x5F,
            0xC3, 0xF1, 0x0B, 0xD6, 0x87, 0xAE, 0xDC, 0x62, 0x6F, 0x8E, 0x8E, 0x9E, 0x09, 0x19, 0xE4,
            0x8A, 0x8D, 0x66, 0xA9, 0x96, 0x4D, 0x4E, 0x21, 0xEF, 0x6E, 0x2E, 0x66, 0xAB, 0x3F, 0xDE,
            0xCD, 0x85, 0x32, 0x31, 0x3E, 0x4C, 0x48, 0x30, 0xFC, 0x80, 0x7A, 0xCC, 0xD9, 0x5B, 0x6C,
            0xC8, 0xB1, 0x5B, 0xA4, 0x8C, 0x1F, 0x0A, 0xB7, 0xEF, 0x5A, 0x24, 0x20, 0x58, 0x67, 0xE9,
            0x65, 0x8B, 0x79, 0x2E, 0xD0, 0xAC, 0xCC, 0x55, 0x71, 0x53, 0xEA, 0x69, 0x06, 0x2F, 0x88,
            0xC6, 0x38, 0x08, 0x7B, 0x2F, 0xC2, 0x40, 0xE3, 0x6B, 0xEF, 0x22, 0x1E, 0xAE, 0x58, 0x81,
            0x6B, 0x0E, 0xF2, 0xA7, 0xC5, 0xA2, 0x11, 0x5B, 0x59, 0x4B, 0x71, 0x08, 0x80, 0x0E, 0x04,
            0x65, 0x20, 0x4C, 0x61, 0xB4, 0x2F, 0x54, 0xF2, 0xED, 0xE6, 0x19, 0x0A, 0x1F, 0x84, 0xE2,
            0x87, 0x69, 0x39, 0x75, 0xDE, 0x04, 0x6C, 0x10, 0x8D, 0x7E, 0x73, 0xD5, 0xF2, 0x85, 0x86,
            0x48, 0xBB, 0xC5, 0x1B, 0x8C, 0xE4, 0x1F, 0xD5, 0x97, 0x35, 0x5F, 0x18, 0x94, 0xAD, 0xA3,
            0x50, 0x65, 0xDC, 0x7D, 0x33, 0x9C, 0x3A, 0xE6, 0xA4, 0x6A, 0x83, 0xD3, 0x21, 0x09, 0x88,
            0xB8, 0x78, 0x36, 0xBF, 0xE9, 0xBA, 0xA6, 0xB7, 0x5F, 0xBF, 0xFA, 0x71, 0x94, 0xC5, 0x50,
            0x49, 0x13, 0x98, 0x6F, 0xA1, 0xBB, 0x41, 0xAE, 0x41, 0xF2, 0xD0, 0x11, 0x33, 0x87, 0xC1,
            0xF6, 0xB2, 0x9F, 0x33, 0xC8, 0x30, 0x90, 0x4D, 0x9E, 0x67, 0xED, 0x6A, 0xEC, 0xAE, 0x44,
            0xD2, 0x48, 0x22, 0x77, 0x3B, 0xE6, 0xF4, 0x6D, 0x71, 0xF7, 0x4A, 0x88, 0x9A, 0x49, 0x96,
            0x29, 0xFC, 0x29, 0x8B, 0xF7, 0x2D, 0xD7, 0xC9, 0x6D, 0xB1, 0xDC, 0xEA, 0x26, 0xF5, 0x23,
            0x1C, 0x61, 0xD5, 0xFD, 0xE2, 0x23, 0xAC, 0xC4, 0xD4, 0x17, 0x0B, 0xF7, 0x11, 0x07, 0x08,
            0x7D, 0x9E, 0xD3, 0xC7, 0x3F, 0xAA, 0x2C, 0x90, 0xFC, 0xDF, 0xAC, 0xC5, 0x83, 0x69, 0xC3,
            0xD1, 0xA7, 0x37, 0x01, 0xC4, 0x62, 0x16, 0xB7, 0xBE, 0x98, 0x36, 0x9F, 0x32, 0x56, 0x24,
            0xBE, 0x34, 0x45, 0x25, 0xCE, 0x51, 0xF2, 0x41, 0x19, 0x17, 0x46, 0xDE, 0x9D, 0x0F, 0x63,
            0xA8, 0xE9, 0x33, 0xE2, 0xE9, 0x75, 0x00, 0x6E, 0x31, 0xFE, 0x4D, 0x5C, 0x0F, 0x43, 0x6C,
            0xA7, 0x5E, 0xE3, 0xF0, 0xB5, 0x1E, 0xC6, 0xE6, 0x4E, 0xD3, 0x43, 0x5B, 0xC5, 0x1D, 0xA7,
            0x30, 0x03, 0xF0, 0x64, 0x9C, 0x1D, 0xEC, 0xA1, 0xED, 0xA1, 0x5C, 0x5F, 0x75, 0x2C, 0x63,
            0x9F, 0x00, 0x11, 0xB4, 0xB6, 0xA5, 0xFE, 0xDF, 0x9A, 0xA0, 0xFE, 0x66, 0xD3, 0x15, 0x42,
            0xB5, 0xF7, 0xFC, 0xE0, 0xD4, 0x17, 0x20, 0x89, 0xB2, 0x96, 0xF9, 0x4A, 0x9C, 0xD4, 0x68,
            0x15, 0x86, 0xD5, 0x21, 0x4C, 0xBE, 0xE5, 0x8C, 0xFC, 0xA2, 0x91, 0x69, 0xF4, 0xC0, 0x51,
            0xF8, 0xB9, 0x40, 0x64, 0x91, 0x86, 0xBA, 0xEE, 0x1F, 0xB6, 0x26, 0x19, 0xB6, 0xEE, 0xA0,
            0x8B, 0x7A, 0x4C, 0x45, 0x1A, 0x02, 0x65, 0x57, 0x63, 0xF8, 0x85, 0xAA, 0xBF, 0x2E, 0x04,
            0x26, 0x74, 0xB2, 0x53, 0x56, 0x00, 0x38, 0x1D, 0xF7, 0xCE, 0x7C, 0x78, 0x2C, 0x7F, 0xDB,
            0xF0, 0x76, 0x5C, 0x83, 0x2E, 0xDB, 0x8B, 0x3C, 0x16, 0xB7, 0xC7, 0x89, 0x76, 0x67, 0x12,
            0x1F, 0x2B, 0x09, 0x9C, 0x99, 0x80, 0x14, 0x77, 0xAF, 0x37, 0x7A, 0xE8, 0x4D, 0x52, 0x8A,
            0xE1, 0x60, 0xD4, 0x3B, 0xA8, 0x6C, 0x43, 0x44, 0xD8, 0x63, 0x76, 0xFC, 0x37, 0xAA, 0x13,
            0x26, 0xB8, 0x5A, 0x66, 0x58, 0x09, 0xE4, 0xC2, 0x04, 0x03, 0xCD, 0x11, 0xBA, 0x0C, 0xE4,
            0x16, 0x80, 0x2A, 0xE9, 0xF1, 0x4D, 0xD7, 0x0B, 0x4E, 0xF6, 0xC2, 0x35, 0x12, 0xC3, 0xAD,
            0xC3, 0xFE, 0x50, 0x01, 0x19, 0x80, 0x1A, 0x9E, 0xC3, 0x3E, 0xEB, 0xD8, 0x19, 0xA2, 0x1D,
            0x29, 0xCA, 0xEA, 0xC8, 0xBB, 0xD9, 0xDD, 0xAC, 0x00, 0xC4, 0xE8, 0x57, 0x56, 0x0A, 0x7D,
            0x55, 0x9D, 0x1F, 0xCE, 0xBB, 0xC4, 0x38, 0x28, 0xD7, 0xE1, 0x06, 0x11, 0xD3, 0x24, 0x06,
            0x70, 0x46, 0xEC, 0x48, 0xC9, 0x7D, 0x06, 0x41, 0x7C, 0x3D, 0x89, 0x1E, 0xD1, 0x98, 0xAF,
            0x12, 0x0E, 0x57, 0x09, 0x17, 0xA6, 0x09, 0xA2, 0xFA, 0xAE, 0x8A, 0x03, 0x60, 0xA5, 0x4E,
            0x13, 0x1B, 0x22, 0xC3, 0xD5, 0x61, 0xDA, 0x03, 0xA2, 0x04, 0x71, 0xD1, 0xE6, 0x82, 0xB1,
            0x9E, 0x95, 0x39, 0x34, 0x1E, 0x0D, 0x6F, 0x2D, 0x2E, 0x69, 0x3A, 0x86, 0x89, 0x5C, 0x81,
            0xF7, 0xBE, 0xDA, 0xB1, 0xC6, 0xB8, 0x5F, 0x0B, 0x48, 0xF6, 0x02, 0x67, 0xD4, 0x78, 0x81,
            0x59, 0x62, 0xCA, 0xC7, 0x0C, 0x56, 0x2C, 0x18, 0x18, 0xA6, 0x7E, 0x46, 0xDB, 0xBA, 0xAC,
            0x79, 0x9E, 0x6D, 0x40, 0xFF, 0x29, 0x26, 0x50, 0x90, 0x7A, 0x69, 0x40, 0xE2, 0xDA, 0xD1,
            0x0F, 0x68, 0xC9, 0xD0, 0xEF, 0x93, 0x17, 0x6F, 0xDB, 0x45, 0x13, 0x26, 0x8D, 0x61, 0x62,
            0x50, 0x2A, 0x7B, 0x84, 0x17, 0xF3, 0x98, 0x52, 0x14, 0x82, 0xDF, 0xC3, 0x4F, 0xA5, 0x62,
            0x82, 0x3F, 0xA2, 0x0B, 0x6C, 0x5A, 0x0C, 0x86, 0x4F, 0x3B, 0x07, 0x08, 0xCE, 0xFA, 0x2A,
            0x7B, 0x2A, 0x63, 0x64, 0xAD, 0x3A, 0xB6, 0x5E, 0xE4, 0xC9, 0xAC, 0x0E, 0xF9, 0x14, 0x51,
            0x21, 0xE1, 0x72, 0x1E, 0x23, 0x1F, 0xCF, 0x62, 0xFB, 0xF6, 0x62, 0x82, 0x78, 0x2A, 0x2D,
            0xF5, 0x88, 0x02, 0xDE, 0x67, 0x63, 0xC2, 0x63, 0x7B, 0xA0, 0xF2, 0xF3, 0x07, 0x98, 0xF5,
            0x23, 0xEF, 0x96, 0x02, 0xCF, 0x13, 0xB6, 0xA2, 0xB1, 0xC3, 0xE3, 0xC2, 0x55, 0x72, 0xC0,
            0x03, 0x74, 0x4D, 0xD3, 0xF6, 0xF4, 0x5D, 0x1F, 0x60, 0x13, 0xD2, 0x06, 0x77, 0x6B, 0x84,
            0x14, 0x10, 0xA7, 0xEF, 0x54, 0x66, 0x73, 0xFA, 0xF4, 0x5B, 0xF1, 0x1E, 0xE3, 0x0C, 0x73,
            0x0E, 0xB3, 0xB7, 0xAC, 0xC3, 0x9D, 0xDC, 0x9B, 0x30, 0xE4, 0x45, 0x4A, 0xA3, 0xF7, 0xE1,
            0xC5, 0xCC, 0x54, 0x55, 0x54, 0xFB, 0x3E, 0xD4, 0x73, 0xEB, 0xBC, 0xAD, 0xC9, 0xA4, 0xEB,
            0xC0, 0x37, 0xF9, 0xED, 0x6B, 0x51, 0x6E, 0x19, 0x25, 0xC4, 0xAD, 0xE6, 0x26, 0xF7, 0x5B,
            0x41, 0x2F, 0xAA, 0xD0, 0x12, 0xFC, 0x30, 0xAB, 0xCA, 0xB6, 0x4E, 0xDC, 0x62, 0x9F, 0x49,
            0x9E, 0xC2, 0x28, 0x4D, 0x8C, 0x7C, 0xEB, 0xA0, 0xD3, 0xC7, 0x17, 0xE8, 0x6B, 0x1F, 0xB0,
            0x11, 0x09, 0xD0, 0x08, 0x80, 0x22, 0xC9, 0x88, 0xC6, 0xD2, 0x1D, 0xD1, 0x69, 0xD8, 0x6B,
            0x67, 0x80, 0x29, 0x69, 0x46, 0x42, 0x91, 0x7F, 0x9F, 0x9F, 0x3A, 0x81, 0x94, 0x5F, 0xE3,
            0x7D, 0xEE, 0xF2, 0xAF, 0xB1, 0xAC, 0x9C, 0x7B, 0x21, 0x3A, 0x71, 0x03, 0xCF, 0x74, 0x1C,
            0x61, 0xB8, 0x71, 0xB0, 0xE7, 0xDE, 0xD9, 0x2D, 0xE4, 0xB6, 0xE0, 0xF5, 0x0F, 0x45, 0x1F,
            0x3A, 0x51, 0x6B, 0x6C, 0x06, 0x8E, 0x69, 0x6A, 0x93, 0x50, 0x27, 0x68, 0x9C, 0x54, 0x02,
            0x0E, 0x41, 0xC8, 0xE3, 0xF1, 0x36, 0x26, 0x60, 0x35, 0x75, 0x0F, 0xAF, 0x2E, 0x9F, 0x7E,
            0x4E, 0x4B, 0x6D, 0x07, 0x90, 0x23, 0x7C, 0xC7, 0x4F, 0x46, 0xC3, 0x1B, 0xA7, 0xA8, 0x52,
            0x8B, 0x47, 0xC3, 0x37, 0x35, 0xD3, 0x60, 0xF3, 0x83, 0x29, 0x41, 0x63, 0xF1, 0xB5, 0xB4,
            0xDF, 0x69, 0x4A, 0x3D, 0xC8, 0xDF, 0xD9, 0x27, 0xD8, 0xA9, 0xA2, 0x72, 0xBB, 0xE4, 0xE6,
            0x3E, 0x18, 0x9F, 0x5E, 0x21, 0x8A, 0xC4, 0x0E, 0xB8, 0x14, 0x9F, 0x62, 0x3F, 0x61, 0x43,
            0x76, 0x53, 0xBB, 0xB2, 0x70, 0x25, 0x34, 0x0F, 0xEC, 0x7F, 0x6B, 0xD9, 0x7D, 0x50, 0xFF,
            0x23, 0x7D, 0xF6, 0x18, 0x9D, 0x4A, 0xD5, 0x19, 0xFF, 0x1B, 0x7F, 0xFB, 0xF4, 0x96, 0x53,
            0x27, 0xCC, 0x7B, 0x91, 0x63, 0xE8, 0xB6, 0x46, 0xCA, 0x47, 0x99, 0xCD, 0x41, 0x49, 0x9A,
            0xA4, 0xF9, 0x50, 0x11, 0x72, 0xC1, 0x59, 0x3E, 0x09, 0xB6, 0xA7, 0x1E, 0xF6, 0xEF, 0xCB,
            0x79, 0xA5, 0x0D, 0xAB, 0x38, 0x9D, 0xF2, 0x30, 0x74, 0xE1, 0x41, 0xE5, 0x46, 0x34, 0x77,
            0x3A, 0x92, 0x6D, 0xD2, 0x09, 0xDB, 0xDD, 0xF7, 0x0D, 0xBB, 0x83, 0x24, 0x8A, 0xFB, 0x5B,
            0x53, 0xFD, 0x00, 0xED, 0x5A, 0xC3, 0xFD, 0x3E, 0x5E, 0xA7, 0x7E, 0x1E, 0x2A, 0x86, 0xD0,
            0x06, 0x9A, 0x06, 0x7E, 0xB2, 0xDB, 0x8B, 0xD6, 0x0E, 0xCC, 0x57, 0x67, 0x5B, 0x48, 0xF6,
            0x5F, 0x27, 0x5C, 0xBD, 0xEB, 0x75, 0x2B, 0x7C, 0x38, 0x74, 0x1A, 0xE2, 0x5E, 0x2C, 0x3C,
            0x8A, 0xCC, 0x06, 0x4A, 0xD5, 0x88, 0xE2, 0x71, 0x05, 0x14, 0xE2, 0xC5, 0x6C, 0xF7, 0xC6,
            0xCF, 0x20, 0xD0, 0xB9, 0x4C, 0x65, 0x72, 0x23, 0x29, 0x6C, 0xF6, 0xC7, 0x2C, 0xC5, 0xAA,
            0xF6, 0xE9, 0xF1, 0xF9, 0xF3, 0x3C, 0xA2, 0x3A, 0xD3, 0x2B, 0x2A, 0x71, 0x15, 0x16, 0xFD,
            0xAD, 0xFC, 0xE6, 0xF2, 0xBD, 0xA8, 0xC9, 0x97, 0xE8, 0x21, 0x1A, 0x73, 0x3A, 0xEE, 0x48,
            0x71, 0xB7, 0x23, 0x16, 0xE6, 0x4A, 0xD0, 0xAD, 0x3E, 0x76, 0x5A, 0x87, 0x08, 0x18, 0xDD,
            0xCC, 0x4F, 0x3F, 0x06, 0x6A, 0x71, 0x0D, 0x28, 0xC6, 0x90, 0xA3, 0x51, 0x72, 0xA7, 0xDD,
            0x1D, 0x10, 0xAC, 0xF6, 0x4B, 0xE2, 0xAF, 0x57, 0xFF, 0xBD, 0x93, 0xA8, 0x87, 0xD9, 0x75,
            0xE1, 0x30, 0x95, 0xE4, 0x2A, 0x47, 0xBE, 0xA7, 0x76, 0x8C, 0x0F, 0xF2, 0x0E, 0x62, 0x60,
    };

    static final GroupElement[] SPAKE_N_SMALL_PRECOMP;
    static final GroupElement[] SPAKE_M_SMALL_PRECOMP;

    static {
        Ed25519CurveParameterSpec spec = Ed25519.getSpec();
        SPAKE_N_SMALL_PRECOMP = getGEFromTable(spec.getCurve(), PRECOMP_TABLE_N);
        SPAKE_M_SMALL_PRECOMP = getGEFromTable(spec.getCurve(), PRECOMP_TABLE_M);
    }

    private final byte[] myName;
    private final byte[] theirName;
    private final Spake2Role myRole;
    private final byte[] privateKey = new byte[32];
    private final byte[] myMsg = new byte[32];
    private final byte[] passwordScalar = new byte[32];
    private final byte[] passwordHash = new byte[64];
    private final Ed25519CurveParameterSpec curveSpec;

    private State state;
    private boolean disablePasswordScalarHack;
    private boolean isDestroyed = false;

    public Spake2Context(Spake2Role myRole,
                         final byte[] myName,
                         final byte[] theirName) {
        this.myRole = myRole;
        this.myName = new byte[myName.length];
        this.theirName = new byte[theirName.length];
        this.state = State.Init;

        System.arraycopy(myName, 0, this.myName, 0, myName.length);
        System.arraycopy(theirName, 0, this.theirName, 0, theirName.length);

        curveSpec = Ed25519.getSpec();
    }

    public void setDisablePasswordScalarHack(boolean disablePasswordScalarHack) {
        this.disablePasswordScalarHack = disablePasswordScalarHack;
    }

    public boolean isDisablePasswordScalarHack() {
        return disablePasswordScalarHack;
    }

    public Spake2Role getMyRole() {
        return myRole;
    }

    public byte[] getMyMsg() {
        return myMsg;
    }

    public byte[] getMyName() {
        return myName;
    }

    public byte[] getTheirName() {
        return theirName;
    }

    @Override
    public boolean isDestroyed() {
        return isDestroyed;
    }

    @Override
    public void destroy() {
        isDestroyed = true;
        Arrays.fill(privateKey, (byte) 0);
        Arrays.fill(myMsg, (byte) 0);
        Arrays.fill(passwordScalar, (byte) 0);
        Arrays.fill(passwordHash, (byte) 0);
    }

    /**
     * @param password Shared password.
     * @return A message of size {@link #MAX_MSG_SIZE}.
     * @throws IllegalArgumentException If SHA-512 is unavailable for some reason.
     * @throws IllegalStateException    If the message has already been generated.
     */
    public byte[] generateMessage(final byte[] password) throws IllegalArgumentException, IllegalStateException {
        byte[] privateKey = new byte[64];
        new SecureRandom().nextBytes(privateKey);
        System.out.printf("PVKEY(%s): %s%n", myRole, Utils.bytesToHex(privateKey));
        return generateMessage(password, privateKey);
    }

    // Package private method for testing purposes
    byte[] generateMessage(final byte[] password, byte[] privateKey) throws IllegalArgumentException, IllegalStateException {
        if (isDestroyed) {
            throw new IllegalStateException("The context was destroyed.");
        }
        if (this.state != State.Init) {
            throw new IllegalStateException("Invalid state: " + this.state);
        }

        Ed25519ScalarOps scalarOps = curveSpec.getScalarOps();

        System.arraycopy(scalarOps.reduce(privateKey), 0, privateKey, 0, 32);
        // Multiply by the cofactor (eight) so that we'll clear it when operating on
        // the peer's point later in the protocol.
        leftShift3(privateKey);
        System.arraycopy(privateKey, 0, this.privateKey, 0, this.privateKey.length);

        final GroupElement P = curveSpec.getB().scalarMultiply(this.privateKey);

        byte[] passwordTmp = getHash("SHA-512", password);  // 64 byte
        System.arraycopy(passwordTmp, 0, this.passwordHash, 0, this.passwordHash.length);

        /**
         * Due to a copy-paste error, the call to {@link #leftShift3(byte[])} was omitted after reducing it, just above.
         * This meant that {@link #passwordScalar} was not a multiple of eight to clear the cofactor and thus three bits
         * of the password hash would leak. In order to fix this in a unilateral way, points of small order are added to
         * the mask point such as that it is in the prime-order subgroup. Since the ephemeral scalar is a multiple of
         * eight, these points will cancel out when calculating the shared secret.
         *
         * Adding points of small order is the same as adding multiples of the prime order to the password scalar. Since
         * that's faster, this what is done below. {@link #l} is a large prime, thus, odd, thus the LSB is one. So,
         * adding it will flip the LSB. Adding twice, it will flip the next bit, and so on for all the bottom three bits.
         */
        Scalar passwordScalar = new Scalar(scalarOps.reduce(passwordTmp));

        /**
         * passwordScalar is the result of scalar reducing and thus is, at most, $l-1$. In the following, we may add
         * $l+2×l+4×l$ for a max value of $8×l-1$. That is less than $2^256$ as required.
         */

        if (!this.disablePasswordScalarHack) {
            Scalar order = new Scalar(l);
            Scalar tmp = new Scalar();
            tmp.copy(order.cmov(tmp, isEqual(passwordScalar.getByte(0) & 1, 1)));
            passwordScalar.copy(passwordScalar.add(tmp));
            order.copy(order.dbl());

            tmp.reset();
            tmp.copy(order.cmov(tmp, isEqual(passwordScalar.getByte(0) & 2, 2)));
            passwordScalar.copy(passwordScalar.add(tmp));
            order.copy(order.dbl());

            tmp.reset();
            tmp.copy(order.cmov(tmp, isEqual(passwordScalar.getByte(0) & 4, 4)));
            passwordScalar.copy(passwordScalar.add(tmp));

            assert ((passwordScalar.getByte(0) & 7) == 0);
        }

        System.arraycopy(passwordScalar.getBytes(), 0, this.passwordScalar, 0, this.passwordScalar.length);

        // mask = h(password) * <N or M>.
        GroupElement mask = geScalarMultiplySmallPrecomp(curveSpec.getCurve(), this.passwordScalar,
                this.myRole == Spake2Role.Alice ? SPAKE_M_SMALL_PRECOMP : SPAKE_N_SMALL_PRECOMP);

        // P* = P + mask.
        GroupElement PStar = P.add(mask.toCached()).toP2();

        System.arraycopy(PStar.toByteArray(), 0, this.myMsg, 0, this.myMsg.length);
        this.state = State.MsgGenerated;
        return this.myMsg.clone();
    }

    /**
     * @param theirMsg Message generated/received from the other end.
     * @return Key of size {@link #MAX_KEY_SIZE}.
     * @throws IllegalArgumentException If the message is invalid or SHA-512 is unavailable for some reason.
     * @throws IllegalStateException    If the key has already been generated.
     */
    public byte[] processMessage(final byte[] theirMsg) throws IllegalArgumentException, IllegalStateException {
        if (isDestroyed) {
            throw new IllegalStateException("The context was destroyed.");
        }
        if (this.state != State.MsgGenerated) {
            throw new IllegalStateException("Invalid state: " + this.state);
        }
        if (theirMsg.length != 32) {
            throw new IllegalArgumentException("Peer's message is not 32 bytes");
        }

        GroupElement QStar = curveSpec.getCurve().fromBytesNegateVarTime(theirMsg);
        if (QStar == null) {
            throw new IllegalArgumentException("Point received from peer was not on the curve.");
        }

        System.out.printf("Q*(%s): %s%n", myRole, Utils.bytesToHex(QStar.toByteArray()));

        // Unmask peer's value.
        GroupElement peersMask = geScalarMultiplySmallPrecomp(curveSpec.getCurve(), this.passwordScalar,
                this.myRole == Spake2Role.Alice ? SPAKE_N_SMALL_PRECOMP : SPAKE_M_SMALL_PRECOMP);

        System.out.printf("PEER'S MASK(%s): %s%n", myRole, Utils.bytesToHex(peersMask.toByteArray()));

        GroupElement QExt = QStar.sub(peersMask.toCached()).toP3();
        // FIXME: Create a single precomp converter or fix generating single precompute
        GroupElement QPrecomp = new GroupElement(QExt.getCurve(), GroupElement.Representation.P3, QExt.getX(),
                QExt.getY(), QExt.getZ(), QExt.getT(), true, true);

        System.out.printf("QExt(%s): %s%n", myRole, Utils.bytesToHex(QExt.toByteArray()));

        byte[] dhShared = QPrecomp.scalarMultiply(this.privateKey).toByteArray();

        System.out.printf("DH(%s): %s%n", myRole, Utils.bytesToHex(dhShared));

        MessageDigest sha;
        try {
            sha = MessageDigest.getInstance("SHA-512");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalArgumentException("SHA-512 algorithm is not supported.");
        }
        if (this.myRole == Spake2Role.Alice) {
            updateWithLengthPrefix(sha, this.myName, this.myName.length);
            updateWithLengthPrefix(sha, this.theirName, this.theirName.length);
            updateWithLengthPrefix(sha, this.myMsg, this.myMsg.length);
            updateWithLengthPrefix(sha, theirMsg, 32);
        } else { // Bob
            updateWithLengthPrefix(sha, this.theirName, this.theirName.length);
            updateWithLengthPrefix(sha, this.myName, this.myName.length);
            updateWithLengthPrefix(sha, theirMsg, 32);
            updateWithLengthPrefix(sha, this.myMsg, this.myMsg.length);
        }
        updateWithLengthPrefix(sha, dhShared, dhShared.length);
        updateWithLengthPrefix(sha, this.passwordHash, this.passwordHash.length);

        byte[] key = sha.digest();
        this.state = State.KeyGenerated;

        return key.clone();
    }

    /**
     * Multiplies n with 8 by shifting it 3 times to the left
     *
     * @param n 32 bytes value
     */
    private static void leftShift3(byte[] n) {
        int carry = 0;
        for (int i = 0; i < 32; i++) {
            int next_carry = (byte) ((n[i] & 0xFF) >>> 5);
            n[i] = (byte) ((n[i] << 3) | carry);
            carry = next_carry;
        }
    }

    /**
     * l = 2^252 + 27742317777372353535851937790883648493
     */
    private static final byte[] l = Utils.hexToBytes("edd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010");


    private static void updateWithLengthPrefix(MessageDigest sha, final byte[] data, int len) {
        byte[] len_le = new byte[8];
        long l = len;
        int i;

        for (i = 0; i < 8; i++) {
            len_le[i] = (byte) (l & 0xFF);
            l = (l >>> 8) & 0xFFFF_FFFFL;
        }

        sha.update(len_le);
        sha.update(data);
    }

    private GroupElement geScalarMultiplySmallPrecomp(Curve curve,
                                                      final byte[] a /* 32 bytes */,
                                                      final GroupElement[] precompTable) {
        GroupElement h = curve.getZero(GroupElement.Representation.P3);
        // This loop does 64 additions and 64 doublings to calculate the result.
        for (long i = 63; i >= 0; i--) {
            int index = 0;

            for (long j = 0; j < 4; j++) {
                byte bit = (byte) (1 & (a[(int) ((8 * j) + (i >>> 3))] >>> (i & 7)));
                index |= (bit << j);
            }

            GroupElement e = curve.getZero(GroupElement.Representation.PRECOMP);
            for (int j = 1; j < 16; j++) {
                e = e.cmov(precompTable[j - 1], Utils.equal(index, j));
            }

            h = h.add(h.toCached()).toP3().madd(e).toP3();
        }
        return h;
    }

    // Package private for testing
    static byte[] getHash(String algo, byte[] bytes) throws IllegalArgumentException {
        MessageDigest md;
        try {
            md = MessageDigest.getInstance(algo);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalArgumentException("Invalid hashing algorithm " + algo);
        }
        md.reset();
        return md.digest(bytes);
    }

    /**
     * @param a 32 bit value
     * @param b 32 bit value
     * @return 0xff...f if a == b and 0x0 otherwise.
     */
    private static long isEqual(long a, long b) {
        return isZero(a ^ b);
    }

    /**
     * @param a 32 bit value
     * @return 0xff...f if a == 0 and 0x0 otherwise.
     */
    private static long isZero(long a) {
        return copyMsbToEveryBit(~a & (a - 1));
    }

    /**
     * @param a 32 bit value
     * @return The given value with the MSB copied to all the other bits.
     */
    private static long copyMsbToEveryBit(long a) {
        // 2's complement of MSB
        return -(a >>> 63);
    }

    private enum State {
        Init,
        MsgGenerated,
        KeyGenerated,
    }

    static class Scalar {
        private final byte[] bytes;

        public Scalar(byte[] bytes) {
            this.bytes = new byte[32];
            System.arraycopy(bytes, 0, this.bytes, 0, 32);
        }

        public Scalar() {
            this.bytes = new byte[32];
        }

        public byte getByte(int idx) {
            return bytes[idx];
        }

        public byte[] getBytes() {
            return bytes;
        }

        public void reset() {
            Arrays.fill(this.bytes, (byte) 0);
        }

        /**
         * Copy bytes from the given scalar
         */
        public void copy(Scalar scalar) {
            System.arraycopy(scalar.bytes, 0, this.bytes, 0, 32);
        }

        /**
         * @return A new scalar with bits copied from this if the mask is all ones.
         */
        public Scalar cmov(Scalar src, long mask) {
            byte[] m = new byte[4];
            m[0] = (byte) mask;
            m[1] = (byte) (mask >>> 8);
            m[2] = (byte) (mask >>> 16);
            m[3] = (byte) (mask >>> 24);
            byte[] bytes = new byte[32];
            for (int i = 0; i < 8; ++i) {
                int idx = i * 4;
                for (int j = 0; j < 4; ++j) {
                    bytes[idx + j] = (byte) (m[j] & this.bytes[idx + j] | (~m[j] & src.bytes[idx + j]));
                }
            }
            return new Scalar(bytes);
        }

        /**
         * @return 2 * this
         */
        Scalar dbl() {
            byte[] bytes = new byte[32];
            int carry = 0;
            for (int i = 0; i < 32; ++i) {
                int carry_out = (this.bytes[i] & 0xFF) >>> 7;
                bytes[i] = (byte) ((this.bytes[i] << 1) | carry);
                carry = carry_out;
            }
            return new Scalar(bytes);
        }

        /**
         * @return src + this
         */
        Scalar add(Scalar src) {
            byte[] bytes = new byte[32];
            int carry = 0;
            for (int i = 0; i < 32; ++i) {
                int tmp = (src.bytes[i] & 0xFF) + (this.bytes[i] & 0xFF) + carry;
                bytes[i] = (byte) tmp;
                carry = tmp >>> 8;
            }
            return new Scalar(bytes);
        }
    }
}
